This code is simple programming lanuage named M.


The feature of the lanuage are
1. variable						:= Variable are declared using 'var' keyword. Every variable used should be declared 
2. conditions stmts				:= current on if(expr) ... endif is supported. 'else' is not supported
3. loops.						:= while(expr) ... endwhile is supported
5. Calling C functions from M.	:= Completed
6. functions.					:= Completed. Recursive functions are supported. Passing arguments to functions are also supported
7. global variables.			:= In progress.
7. Objects.						:= Done.

Local variables are defined as and when they are encountered. (this will change soon).


Syntax of M language.

A factorial program

==========Start of factorial program ==================

n:=10;
fact:=1;
i:=1
while(i <= n)
	fact:=fact * i;
	i := i+1;
endwhile
output("fact(", n, ") = ", fact);	#this is native call, and the registered C function gets called
if(fact > 1000)
	output("fact( ", fact, ") is huge number");
endif

=========End of program==================

This source code for M has the following parts.

1. Compiler 	
	we use the lemon parser to generate the C code from context free grammer.
	This parser generates the byte code from the program. The byte code generated
	is of register architecture insted of stack architecture.
	
	What's register architecture.

	Consider this statment 
	a*(b+c)

	the above statment can be solved in two ways.

	the stack architecture
	PUSH A
	PUSH B
	PUSH C
	ADD		=> adds B & C and pushes the result back to stack
	MUL		=> MUL A and (B&C value pushed into stack) and push the result back.

	In the register architecture the same expression becomes
	ADD B, C, %1	=> add B and C and copy it to register 1
	MUL A, %1, %2	=> add A and register 1 and copy the result to register 2

	To See the generated bytecode Uncomment the macro in compiler.c file.

	The grammer is written for the lemon parsers. (google about lemon parser for more information)
	Lemon parser is used in sqlite.

	The grammer understands the M lanuage syntax and generates the byteCode. 

	The grammer is in the file grammer.y
	
	The compiler files are grammer.y, executable.c, functions.c 

2. Tokenzier 	 
	This is written in flex and c. This program reads a file and then generates a set of tokens 
	from the file. Examaple
	
	a:=10*width;
	the program generates the following tokens
	variable  a
	operator := 
	Numebr	 10
	variable width

	These are then passed to grammer to check if this syntax is correct
	and then byte code are generated from the output of grammer.

	See files lexel.l, tokenizer.c files for the tokenizers.

3. Interpreters	 
	This interprets the byte code generated by the compiler. 
	The interpreter uses a set of stacks, linked list to execute the byte code.

	The files are execute_context.c


The memory leaks are monitered using valgrind. 
Till now there is no memory leaks in the code.
